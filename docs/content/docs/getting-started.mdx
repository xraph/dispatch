---
title: Getting Started
description: Install Dispatch and process your first job in under five minutes.
---

## Prerequisites

- Go 1.25 or later
- A Go module (`go mod init`)

## Install

```bash
go get github.com/xraph/dispatch
```

## Step 1: Create a Dispatcher

Every Dispatcher requires a store backend. For development and testing, use the in-memory store:

```go
package main

import (
    "context"
    "log"

    "github.com/xraph/dispatch"
    "github.com/xraph/dispatch/store/memory"
)

func main() {
    ctx := context.Background()

    d, err := dispatch.New(
        dispatch.WithStore(memory.New()),
    )
    if err != nil {
        log.Fatal(err)
    }

    _ = d
}
```

## Step 2: Define a job

A job definition is a typed Go function. The input struct is JSON-serialized at enqueue time and deserialized before execution:

```go
import (
    "github.com/xraph/dispatch/job"
)

type EmailInput struct {
    To      string `json:"to"`
    Subject string `json:"subject"`
    Body    string `json:"body"`
}

var SendEmail = job.NewDefinition("send_email",
    func(ctx context.Context, input EmailInput) error {
        log.Printf("sending email to %s: %s", input.To, input.Subject)
        return nil
    },
)
```

## Step 3: Build the engine and register jobs

The `engine` package wires all subsystems. Register job definitions at startup:

```go
import "github.com/xraph/dispatch/engine"

eng := engine.Build(d)
engine.Register(eng, SendEmail)
```

## Step 4: Start the dispatcher

```go
if err := d.Start(ctx); err != nil {
    log.Fatal(err)
}
defer d.Stop(ctx)
```

The engine starts polling for pending jobs and dispatching them to workers.

## Step 5: Enqueue a job

```go
engine.Enqueue(ctx, eng, SendEmail, EmailInput{
    To:      "user@example.com",
    Subject: "Welcome to Acme",
    Body:    "Thanks for signing up!",
})
```

`Enqueue` serializes the input to JSON and persists the job in `pending` state. A worker picks it up on the next poll cycle.

## Step 6: Mount the admin API (optional)

```go
import (
    "net/http"
    "github.com/xraph/dispatch/api"
)

mux := http.NewServeMux()
api.RegisterRoutes(mux, eng)

log.Fatal(http.ListenAndServe(":8080", mux))
```

The admin API exposes HTTP endpoints for inspecting jobs, workflows, crons, DLQ entries, and stats.

## Next steps

- [Architecture](/docs/architecture) — Understand how the packages fit together
- [Jobs](/docs/subsystems/jobs) — Typed definitions, priorities, retries, and backoff
- [Workflows](/docs/subsystems/workflows) — Durable multi-step functions with checkpointing
- [Stores](/docs/stores/postgres) — Connect to PostgreSQL for production
